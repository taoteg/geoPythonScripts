"""
Python script to create a grid basedon bounding box extents in decimanl degrees.
"""

########################
# Module Imports.
########################

import sys
import argparse
import math
import re
# import urllib.request
import shapefile as shp
# from pyproj import Proj, transform


########################
# Input Parameters
########################

helpDescription = "This script requires 7 arguments: minLong, minLat, maxLong, maxLat, cellWidth, cellHeight, output file basename. \n"
helpDescription += "The minX, minY, maxX and maxY should be in DD (decimal degrees). \n"
helpDescription += "The cellWidth and cellHeight should be in meters. \n"
helpDescription += "The output file name should be a single string (underscores are okay). \n"

parser = argparse.ArgumentParser(description=helpDescription, usage='use "%(prog)s --help" for more information', formatter_class=argparse.RawTextHelpFormatter)
parser.add_argument("coordType", help="A string that specifices the type of coordinates used to define the bounding box, use 'dd' if in decimal degrees, use 'dms' if in degrees minutes seconds.")
parser.add_argument("minLong", help="The minimum Longitude (N/S or X) for the coordinate bounding box in DD (decimal degrees).", type=int)
parser.add_argument("minLat", help="The minimum Latitude (E/W or Y) for the coordinate bounding box in DD (decimal degrees).", type=int)
parser.add_argument("maxLong", help="The maximum Longitude (N/S or X) for the coordinate bounding box in DD (decimal degrees).", type=int)
parser.add_argument("maxLat", help="The maximum Latitude (E/W or Y) for the coordinate bounding box in DD (decimal degrees).", type=int)
parser.add_argument("cellWidth", help="The cell width to create in meters.", type=int)
parser.add_argument("cellHeight", help="The cell height to create in meters.", type=int)
parser.add_argument("outputFilename", help="The base name of the output file(s) generated by the script.")
args = parser.parse_args()

if len(sys.argv) != 9:    # 9 to include sys.argv[0].
    print("The script generateEmptyGrid.py requires 6 parameters: minx, miny, maxx, maxy, cell size (in meters), output file name.")
    print("You passed in the following argumanets: ")
    for x in sys.argv:
        print("Argument: ", x)
    print("Exiting script.")
    sys.exit(1)

########################
# Module variables.
########################

scriptName = sys.argv[0]
coordType = sys.argv[1]
minLat = float(sys.argv[2])
minLong = float(sys.argv[3])
maxLat = float(sys.argv[4])
maxLong = float(sys.argv[5])
cellWidth = int(sys.argv[6])
cellHeight = int(sys.argv[7])
fileBaseName = sys.argv[8]

parameters = [scriptName, coordType, minLat, minLong, maxLat, maxLong, cellWidth, cellHeight, fileBaseName]

# """
# Log out parameter values for testing.

# print(len(parameters))

for idx, val in enumerate(parameters):
    print('---------------')
    print('Argument: ', idx, val)
    print('Argument Type: ', type(val))
    print('\n')
# """

########################
# Module Methods.
########################

"""
# Convert DMS to DD.
def dd2dms_old(longitude, latitude):
    # math.modf() splits whole number and decimal into tuple
    # eg 53.3478 becomes (0.3478, 53)
    split_degx = math.modf(longitude)

    # the whole number [index 1] is the degrees
    degrees_x = int(split_degx[1])

    # multiply the decimal part by 60: 0.3478 * 60 = 20.868
    # split the whole number part of the total as the minutes: 20
    # abs() absoulte value - no negative
    minutes_x = abs(int(math.modf(split_degx[0] * 60)[1]))

    # multiply the decimal part of the split above by 60 to get the seconds
    # 0.868 x 60 = 52.08, round excess decimal places to 2 places
    # abs() absoulte value - no negative
    seconds_x = abs(round(math.modf(split_degx[0] * 60)[0] * 60, 2))

    # repeat for latitude
    split_degy = math.modf(latitude)
    degrees_y = int(split_degy[1])
    minutes_y = abs(int(math.modf(split_degy[0] * 60)[1]))
    seconds_y = abs(round(math.modf(split_degy[0] * 60)[0] * 60, 2))

    # account for E/W & N/S
    if degrees_x < 0:
        EorW = "W"
    else:
        EorW = "E"

    if degrees_y < 0:
        NorS = "S"
    else:
        NorS = "N"

    # abs() remove negative from degrees, was only needed for if-else above
    print("\t" + str(abs(degrees_x)) + u"\u00b0 " + str(minutes_x) + "' " + str(seconds_x) + "\" " + EorW)
    print("\t" + str(abs(degrees_y)) + u"\u00b0 " + str(minutes_y) + "' " + str(seconds_y) + "\" " + NorS)
"""

# NOTE: these calculations are precise down to 1.1132 meter at the equator (5 decimal places in the DD value).


def dms2dd(degrees, minutes, seconds, direction):
    dd = float(degrees) + (float(minutes) / 60) + (float(seconds) / (60 * 60))
    if direction == 'S' or direction == 'W':
        dd *= -1
    # print('dms2dd: ', dd)
    return dd


def dd2dms(deg):
    d = int(deg)
    md = abs(deg - d) * 60
    m = int(md)
    sd = (md - m) * 60
    # print('dd2dms: ', d, m, sd)
    return [d, m, sd]


def parse_dms(dms):
    parts = re.split("""[°'",]+""", dms)
    # print(parts)
    lat = dms2dd(parts[0], parts[1], parts[2], parts[3])
    lng = dms2dd(parts[4], parts[5], parts[6], parts[7])
    # print('parse_dms: ', lat, lng)
    return (lat, lng)


########################
# Module Method Testing.
########################

"""
# Test dd2dms()

coords = [["Dublin", -6.2597, 53.3478],["Paris", 2.3508, 48.8567],["Sydney", 151.2094, -33.8650],["Ft.Worth", -97.546649, 32.550058],["Dallas", -97.034774, 32.987978]]

for city,x,y in coords:
    print(city + ":")
    dd2dms(x, y)

# Expected Results:
# Dublin:       6° 15' 34.92" W, 	53° 20' 52.08" N
# Paris: 	    2° 21' 2.88" E, 	48° 51' 24.12" N
# Sydney:       151° 12' 33.84" E,  33° 51' 54.0" S
# Ft.Worth:     97° 32' 47.94" W,   32° 33' 0.21" N
# Dallas:       97° 2' 5.19" W,     32° 59' 16.72" N

# latDD(!Latitude!)
test_latDD = latDD('6° 15' 34.92"')
print(test_latDD)
"""

# INPUTS TESTS.
# Coordinate A DD:      32.550058,-97.546649
# Coordinate A DMS:     32°33'00.2"N 97°32'47.9"W
# Coordinate B DD:      32.987978,-97.034774
# Coordinate B DMS:     32°59'16.7"N 97°02'05.2"W

# print("------------------------------")
# print("""Inputs: 32°33'00.2"N 97°32'47.9"W | 32.550058,-97.546649""")
# # CORRECT SOLUTION! Comma between coords, added comma to split list in method.
# dd = parse_dms("""32°33'00.2"N, 97°32'47.9"W""")
# print(dd)
# print(dd2dms(32.550058))
# print(dd2dms(-97.546649))
# print("\n")
#
# print("------------------------------")
# print("""Inputs: 32°59'16.7"N 97°02'05.2"W | 32.987978,-97.034774""")
# # CORRECT SOLUTION! Comma between coords, added comma to split list in method.
# dd = parse_dms("""32°59'16.7"N, 97°02'05.2"W""")
# print(dd)
# print(dd2dms(32.987978))
# print(dd2dms(-97.034774))
# print("\n")

########################
# Module Logic.
########################

"""
Reading a Shapefile.
"""

# 1) Create Shapefile Reader using input shapefile.
# sf = shp.Reader('')

# 2) Print geometry type of shapefile.
# print(sf.shapeType)


"""
Writing a Shapefile.
"""

# Create a shapefile writer.
w = shp.Writer()

"""
To help prevent accidental misalignment pyshp has an "auto balance" feature to make sure when you add either a shape or a record the two sides of the equation line up. This way if you forget to update an entry the shapefile will still be valid and handled correctly by most shapefile software. Autobalancing is NOT turned on by default. To activate it set the attribute autoBalance to 1 or True
"""

w.autoBalance = 1

"""
Geometry is added using one of several convenience methods. The "null" method is used for null shapes, "point" is used for point shapes, "line" for lines, and "poly" is used for polygons and everything else.
"""

# Creating a point:
# w.shapeType = 5
w = shp.Writer(shapeType=shp.POINT)

# Create fields for attribute values.
w.field('field0', 'C')
w.field('field1', 'C')
w.field('field2', 'C')

# Populate the fields with record values.
w.record('name', 'one', 'two')

# Define point coordinates.
w.point(122, 45)

# Write the shapefile.
w.save('shapefiles/test/point_08')



# if(coordType == 'dd'):
#     print('coordinate type: decimal degrees')



# if(coordType == 'dms'):
#     print('coordinate type: degrees minutes seconds')



"""
# Script inputs.
minx = 448262.080078
miny = 6262492.020081
maxx = 450360.750122
maxy = 6262938.950073

# Grid size.
dx = 10    # 100
dy = 10    # 100

# Filename.

nx = int(math.ceil(abs(maxx - minx)/dx))
ny = int(math.ceil(abs(maxy - miny)/dy))

w = shp.Writer(shp.POLYGON)
w.autoBalance = 1
w.field("ID")
id=0

for i in range(ny):
    for j in range(nx):
        id+=1
        vertices = []
        parts = []
        vertices.append([min(minx+dx*j,maxx),max(maxy-dy*i,miny)])
        vertices.append([min(minx+dx*(j+1),maxx),max(maxy-dy*i,miny)])
        vertices.append([min(minx+dx*(j+1),maxx),max(maxy-dy*(i+1),miny)])
        vertices.append([min(minx+dx*j,maxx),max(maxy-dy*(i+1),miny)])
        parts.append(vertices)
        w.poly(parts)
        w.record(id)

w.save('polygon_grid_dd_test01')
"""
