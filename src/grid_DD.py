"""
Python script to create a grid based on bounding box extents in decimal degrees or degrees minutes seconds.
"""


########################
# Module Imports.
########################

import sys
import os
from pathlib import Path
import argparse
import math
import re
import shapefile as shp
import pygeoj
from pyproj import Proj, transform
import urllib.request


########################
# Input Parameters
########################

helpDescription = "This script requires 8 arguments: coordinateInputs, minLong, minLat, maxLong, maxLat, cellWidth, cellHeight, output file basename. \n"
helpDescription += "The coordinateInputs should be a string indicating whether dd or dms values are used for generating an empty grid. \n"
helpDescription += "The minX, minY, maxX and maxY should be in DD (decimal degrees). \n"
helpDescription += "The cellWidth and cellHeight should be in meters. \n"
helpDescription += "The output file name should be a single string (underscores are okay). \n"

parser = argparse.ArgumentParser(description=helpDescription, usage='use "%(prog)s --help" for more information', formatter_class=argparse.RawTextHelpFormatter)
parser.add_argument("coordType", help="A string that specifices the type of coordinates used to define the bounding box: \n - use 'dd' if in decimal degrees. \n - use 'dms' if in degrees minutes seconds.")
parser.add_argument("minLong", help="The minimum Longitude (N/S or X) for the coordinate bounding box in DD (decimal degrees).", type=int)
parser.add_argument("minLat", help="The minimum Latitude (E/W or Y) for the coordinate bounding box in DD (decimal degrees).", type=int)
parser.add_argument("maxLong", help="The maximum Longitude (N/S or X) for the coordinate bounding box in DD (decimal degrees).", type=int)
parser.add_argument("maxLat", help="The maximum Latitude (E/W or Y) for the coordinate bounding box in DD (decimal degrees).", type=int)
parser.add_argument("cellWidth", help="The cell width to create in meters.", type=int)
parser.add_argument("cellHeight", help="The cell height to create in meters.", type=int)
parser.add_argument("outputFilename", help="The base name of the output file(s) generated by the script.")
args = parser.parse_args()

if len(sys.argv) != 9:    # 9 to include sys.argv[0].
    print("The script generateEmptyGrid.py requires 6 parameters: minx, miny, maxx, maxy, cell size (in meters), output file name.")
    print("You passed in the following argumanets: ")
    for x in sys.argv:
        print("Argument: ", x)
    print("Exiting script.")
    sys.exit(1)


########################
# Module variables.
########################

# Input Parameters
scriptName = sys.argv[0]
coordType = sys.argv[1]
minLat = float(sys.argv[2])
minLong = float(sys.argv[3])
maxLat = float(sys.argv[4])
maxLong = float(sys.argv[5])
cellWidth = int(sys.argv[6])
cellHeight = int(sys.argv[7])
fileBaseName = sys.argv[8]

parameters = [scriptName, coordType, minLat, minLong, maxLat, maxLong, cellWidth, cellHeight, fileBaseName]

"""
# Log out parameter values for testing.
print(len(parameters))
for idx, val in enumerate(parameters):
    print('---------------')
    print('Argument: ', idx, val)
    print('Argument Type: ', type(val))
    print('\n')
"""

# Vars
cwd = os.getcwd()
# print(cwd)
base_path = os.path.abspath('.')
# print(base_path)
base_path = Path(".").resolve()
print(base_path)
target_path = 'shapefiles/grid_DD/'
print(target_path)
output_path = os.path.join(str(base_path), str(target_path))
print(output_path)

########################
# Module Methods.
########################

# NOTE: these calculations are precise down to 1.1132 meter at the equator (5 decimal places in the DD value).


def dms2dd(degrees, minutes, seconds, direction):
    dd = float(degrees) + (float(minutes) / 60) + (float(seconds) / (60 * 60))
    if direction == 'S' or direction == 'W':
        dd *= -1
    # print('dms2dd: ', dd)
    return dd


def dd2dms(deg):
    d = int(deg)
    md = abs(deg - d) * 60
    m = int(md)
    sd = (md - m) * 60
    # print('dd2dms: ', d, m, sd)
    return [d, m, sd]


def parse_dms(dms):
    parts = re.split("""[Â°'",]+""", dms)
    # print(parts)
    lat = dms2dd(parts[0], parts[1], parts[2], parts[3])
    lng = dms2dd(parts[4], parts[5], parts[6], parts[7])
    # print('parse_dms: ', lat, lng)
    return (lat, lng)


# function to generate .prj file information using spatialreference.org
def getWKT_PRJ(epsg_code):
     # access projection information
     # NOTE: urllib.urlopen is now urllib.request.urlopen.
     wkt = urllib.request.urlopen("http://spatialreference.org/ref/epsg/{0}/prettywkt/".format(epsg_code))
     """
     ERROR:
        Traceback (most recent call last):
          File "src/grid_DD.py", line 192, in <module>
            epsg = getWKT_PRJ("4326")
          File "src/grid_DD.py", line 144, in getWKT_PRJ
            remove_spaces = wkt.read().replace(" ","")
        TypeError: a bytes-like object is required, not 'str'
     """
     # wkt = urllib.request.urlopen("http://spatialreference.org/ref/epsg/{0}/prettywkt/".format(epsg_code)).text
     """
     ERROR:
        Traceback (most recent call last):
          File "src/grid_DD.py", line 179, in <module>
            epsg = getWKT_PRJ("4326")
          File "src/grid_DD.py", line 129, in getWKT_PRJ
            wkt = urllib.request.urlopen("http://spatialreference.org/ref/epsg/{0}/prettywkt/".format(epsg_code)).text
        AttributeError: 'HTTPResponse' object has no attribute 'text'
     """
     wkt_str = b'wkt'.decode("utf-8")
     print(wkt_str)
     # remove spaces between charachters
     # remove_spaces = wkt.read().replace(" ","")
     remove_spaces = wkt_str.read().replace(" ","")
     # place all the text on one line
     output = remove_spaces.replace("\n", "")
     return output


########################
# Module Logic.
########################

"""
Reading Input Shapefile.
"""

# 1) Create Shapefile Reader using input shapefile.
# sf = shp.Reader('')

# 2) Print geometry type of shapefile.
# print(sf.shapeType)


"""
Generating Fishnet Grid.
"""

if(coordType == 'dd'):
    print('input coordinate type: decimal degrees')
    print('using decimal degrees inputs')


if(coordType == 'dms'):
    print('input coordinate type: degrees minutes seconds')
    print('using degrees minutes seconds inputs')


"""
Generate a projection file.

# Example Projection File:
 GEOGCS["WGS84",DATUM["WGS_1984",SPHEROID["WGS84",6378137,298.257223563,AUTHORITY["EPSG","7030"]],AUTHORITY["EPSG","6326"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.01745329251994328,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4326"]]
"""

# create the .prj file
prj_filename = fileBaseName + '.prj'
prj_file = output_path + prj_filename
# print(prj_filename)
prj = open(prj_file, "w")
# call the function and supply the epsg code
epsg = getWKT_PRJ("4326")
prj.write(epsg)
prj.close()


"""
Writing Output Shapefile.
"""
# Create a shapefile writer.
w = shp.Writer()

"""
To help prevent accidental misalignment pyshp has an "auto balance" feature to make sure when you add either a shape or a record the two sides of the equation line up. This way if you forget to update an entry the shapefile will still be valid and handled correctly by most shapefile software. Autobalancing is NOT turned on by default. To activate it set the attribute autoBalance to 1 or True
"""

# Manually balancing records and fields.
# w.autoBalance = 0
# ... (add records and geometry)
# w.balance()

# Autobalancing records and fields.
w.autoBalance = 1

"""
Geometry is added using one of several convenience methods. The "null" method is used for null shapes, "point" is used for point shapes, "line" for lines, and "poly" is used for polygons and everything else.
"""

# Creating a point:
# w.shapeType = 5
w = shp.Writer(shapeType=shp.POINT)

# Define point coordinates.
w.point(125, 50)

# Create fields for attribute values ['field_name', 'field_type']
# C :: Text or Character
# D :: Date
# N :: Numeric
# F :: Numeric
# L :: Boolean

shp_fields = [['name', 'C'], ['_id', 'C'], ['value', 'C']]
num_fields = len(shp_fields)
# print(num_fields)

for i in range(num_fields):
    print(shp_fields[i])
    print(shp_fields[i][0])
    print(shp_fields[i][1])
    w.field(shp_fields[i][0], shp_fields[i][1])

# Populate the fields with record values.
w.record('test_point_10', '010', '50')
w.record('test_point_11', '011', '51')

shp_records = [['test_point_10', '010', '10'], ['test_point_11', '011', '11'],]
num_records = len(shp_records)
print(num_records)

# for i in range(num_records):
#     print(shp_records[i])
#     print(shp_records[i][0])
#     print(shp_records[i][1])
#     print(shp_records[i][2])
    # w.field(shp_fields[i][0], shp_fields[i][1])

# Define point coordinates.
# w.point(122, 45)

# Write the shapefile.
w.save('shapefiles/grid_DD/point_10')



"""
# Script inputs.
minx = 448262.080078
miny = 6262492.020081
maxx = 450360.750122
maxy = 6262938.950073

# Grid size.
dx = 10    # 100
dy = 10    # 100

# Filename.

nx = int(math.ceil(abs(maxx - minx)/dx))
ny = int(math.ceil(abs(maxy - miny)/dy))

w = shp.Writer(shp.POLYGON)
w.autoBalance = 1
w.field("ID")
id=0

for i in range(ny):
    for j in range(nx):
        id+=1
        vertices = []
        parts = []
        vertices.append([min(minx+dx*j,maxx),max(maxy-dy*i,miny)])
        vertices.append([min(minx+dx*(j+1),maxx),max(maxy-dy*i,miny)])
        vertices.append([min(minx+dx*(j+1),maxx),max(maxy-dy*(i+1),miny)])
        vertices.append([min(minx+dx*j,maxx),max(maxy-dy*(i+1),miny)])
        parts.append(vertices)
        w.poly(parts)
        w.record(id)

w.save('polygon_grid_dd_test01')
"""
