"""
Python script to create a square grid of size 1m.
"""

# Module imports.
import sys
import argparse
import shapefile as shp
from pyproj import Proj, transform
import urllib.request
import math


# Gather input parameters using argsparser.
helpDescription = "The script generateEmptyGrid.py requires 6 arguments: minLong, minLat, maxLong, maxLat, cell size, output filename."
helpDescription += "The minX, minY, maxX and maxY should be in DD (decimal degrees)."
helpDescription += "The cell size should be in meters."
helpDescription += "The output file name must be a single word, combined words using underscores, or in double quotes."

parser = argparse.ArgumentParser(description=helpDescription)
parser.add_argument("minLong", help="The minimum Longitude (N/S or X) for the coordinate bounding box in DD (decimal degrees).", type=float)
parser.add_argument("minLat", help="The minimum Latitude (E/W or Y) for the coordinate bounding box in DD (decimal degrees).", type=float)
parser.add_argument("maxLong", help="The maximum Longitude (N/S or X) for the coordinate bounding box in DD (decimal degrees).", type=float)
parser.add_argument("maxLat", help="The maximum Latitude (E/W or Y) for the coordinate bounding box in DD (decimal degrees).", type=float)
parser.add_argument("cellWidth", help="The cell width to create in meters.", type=int)
parser.add_argument("cellHeight", help="The cell height to create in meters.", type=int)
parser.add_argument("outputFilename", help="The base name of the output file(s) generated by the script.")
args = parser.parse_args()

if len (sys.argv) != 8 :    # 8 to include sys.argv[0].
    print("The script generateEmptyGrid.py requires 6 parameters: minx, miny, maxx, maxy, cell size (in meters), output file name.")
    print("You passed in the following argumanets: ")
    for x in sys.argv:
        print("Argument: ", x)
    print("Exiting script.")
    sys.exit (1)

scriptName = sys.argv[0]
minLat = float(sys.argv[1])
minLong = float(sys.argv[2])
maxLat = float(sys.argv[3])
maxLong = float(sys.argv[4])
cellWidth = int(sys.argv[5])
cellHeight = int(sys.argv[6])
fileBaseName = sys.argv[7]

# print(scriptName, minLat, minLong, maxLat, maxLong, cellWidth, cellHeight, fileBaseName)
# print(type(scriptName), type(minLat), type(minLong), type(maxLat), type(maxLong), type(cellWidth), type(cellHeight), type(fileBaseName))

# print(minLat, minLong, maxLat, maxLong, cellWidth, cellHeight, fileBaseName)
# print(type(minLat), type(minLong), type(maxLat), type(maxLong), type(cellWidth), type(cellHeight), type(fileBaseName))


"""
Latitude (Northing)

When looking at a map, latitude lines run horizontally.
Latitude lines are also known as parallels since they are parallel and are an equal distant from each other.
Each degree of latitude is approximately 69 miles (111 km) apart; there is a variation due to the fact that the earth is not a perfect sphere but an oblate ellipsoid (slightly egg-shaped).
To remember latitude, imagine them as the horizontal rungs of a ladder ("ladder-tude").
Degrees latitude are numbered from 0° to 90° north and south.
Zero degrees is the equator, the imaginary line which divides our planet into the northern and southern hemispheres.
90° north is the North Pole and 90° south is the South Pole.

Longitude (Easting)

The vertical longitude lines are also known as meridians.
They converge at the poles and are widest at the equator (about 69 miles or 111 km apart).
Zero degrees longitude is located at Greenwich, England (0°).
The degrees continue 180° east and 180° west where they meet and form the International Date Line in the Pacific Ocean.
Greenwich, the site of the British Royal Greenwich Observatory, was established as the site of the prime meridian by an international conference in 1884.

Summary

Latitude (parallels) [horizontal rings eg. "ladder-tude"]
Longitude (meridians) [vertical lines]

Which is X, which is Y?

In ESRI, Lat = Y Long = X

It's easy to get backwards.
On a standard north facing map, latitude is represented by horizontal lines, which go up and down (North and South) the Y axis.
Its easy to think that since they are horizontal lines, they would be on the x axis, but they are not.
So similarly, the X axis is Longitude, as the values shift left to right (East and West) along the X axis.
Confusing for the same reason since on a north facing map, these lines are vertical.

DMS vs DD

The degrees, minutes, seconds (DMS) coordinate values need to be convert to decimal degrees (dd) before calculation.
http://www.rapidtables.com/convert/number/degrees-to-degrees-minutes-seconds.htm
http://www.rapidtables.com/convert/number/degrees-minutes-seconds-to-degrees.htm

How to convert decimal degrees to degrees,minutes,seconds

One degree (°) is equal to 60 minutes (') and equal to 3600 seconds ("):
    1° = 60' = 3600"
The integer degrees (d) are equal to the integer part of the decimal degrees (dd):
    d = integer(dd)
The minutes (m) are equal to the integer part of the decimal degrees (dd) minus integer degrees (d) times 60:
    m = integer((dd - d) × 60)
The seconds (s) are equal to the decimal degrees (dd) minus integer degrees (d) minus minutes (m) divided by 60 times 3600:
    s = (dd - d - m/60) × 3600

Example:
Convert 30.263888889° angle to degrees,minutes,seconds:
    d = integer(30.263888889°) = 30°
    m = integer((dd - d) × 60) = 15'
    s = (dd - d - m/60) × 3600 = 50"
Result:
    30.263888889° = 30° 15' 50"
"""


# Convert DMS to DD.
def dd2dms(longitude, latitude):

    # math.modf() splits whole number and decimal into tuple
    # eg 53.3478 becomes (0.3478, 53)
    split_degx = math.modf(longitude)

    # the whole number [index 1] is the degrees
    degrees_x = int(split_degx[1])

    # multiply the decimal part by 60: 0.3478 * 60 = 20.868
    # split the whole number part of the total as the minutes: 20
    # abs() absoulte value - no negative
    minutes_x = abs(int(math.modf(split_degx[0] * 60)[1]))

    # multiply the decimal part of the split above by 60 to get the seconds
    # 0.868 x 60 = 52.08, round excess decimal places to 2 places
    # abs() absoulte value - no negative
    seconds_x = abs(round(math.modf(split_degx[0] * 60)[0] * 60,2))

    # repeat for latitude
    split_degy = math.modf(latitude)
    degrees_y = int(split_degy[1])
    minutes_y = abs(int(math.modf(split_degy[0] * 60)[1]))
    seconds_y = abs(round(math.modf(split_degy[0] * 60)[0] * 60,2))

    # account for E/W & N/S
    if degrees_x < 0:
        EorW = "W"
    else:
        EorW = "E"

    if degrees_y < 0:
        NorS = "S"
    else:
        NorS = "N"

    # abs() remove negative from degrees, was only needed for if-else above
    print("\t" + str(abs(degrees_x)) + u"\u00b0 " + str(minutes_x) + "' " + str(seconds_x) + "\" " + EorW)
    print("\t" + str(abs(degrees_y)) + u"\u00b0 " + str(minutes_y) + "' " + str(seconds_y) + "\" " + NorS)

"""
# Test DD to DMS conversion.

# Some coords of cities
coords = [["Dublin", -6.2597, 53.3478],["Paris", 2.3508, 48.8567],["Sydney", 151.2094, -33.8650],["Ft.Worth", -97.546649, 32.550058],["Dallas", -97.034774, 32.987978]]

# Test dd2dms()
for city,x,y in coords:
    print(city + ":")
    dd2dms(x, y)
"""


# Convert DD to DMS.
# Not Working. Not really necessary.
"""
def latDD(x):   # x = latitude or longitude.
    D = int(x[1:3])
    M = int(x[3:5])
    S = float(x[5:])
    DD = D + float(M)/60 + float(S)/3600
    return DD
"""


# Generate a projection file.
"""
def getWKT_PRJ (epsg_code):
    # import urllib
    # wkt = urllib.urlopen("http://spatialreference.org/ref/epsg/{0}/prettywkt/".format(epsg_code))
    with urllib.request.urlopen("http://spatialreference.org/ref/epsg/{0}/prettywkt/".format(epsg_code)) as url:
        wkt = url.read()
        # print(wkt)

        # json = url.read()
        # print(json)
        # wkt = json.loads(response.decode('utf-8'))
        # print(wkt)

    remove_spaces = wkt.read().replace(" ","")
    output = remove_spaces.replace("\n", "")
    return output

# create the .prj file
prjFileName = fileBaseName + ".prj"
prj = open(prjFileName, "w")

# call the function and supply the epsg code
epsg = getWKT_PRJ("4326")
prj.write(epsg)
prj.close()
"""


# Script inputs.
# minx = 448262.080078
# miny = 6262492.020081
# maxx = 450360.750122
# maxy = 6262938.950073
minx = float(minLong)
miny = float(minLat)
maxx = float(maxLong)
maxy = float(maxLat)

# Grid size in meters.
# dx = 50    # 100
# dy = 50    # 100
dx = int(cellWidth)
dy = int(cellHeight)

# print(minx, type(minx), miny, type(miny), maxx, type(maxx), maxy, type(maxy), dx, type(dx), dy, type(dy))

# Determine grid size.
nx = int(math.ceil(abs(maxx - minx)/dx))
ny = int(math.ceil(abs(maxy - miny)/dy))

# shp_folder = "."
# shpf = shapefile.Reader(shp_folder + "Ireland_LA.shp")
# shapefileName = "Ireland_LA.shp"
# shpf = shapefile.Reader(shapefileName)
# fields = shpf.fields

# Generate grid file.
w = shp.Writer(shp.POLYGON)
w.autoBalance = 1
# wgs_fields = w.fields
w.field("ID")
id=0

for i in range(ny):
    for j in range(nx):
        id+=1
        vertices = []
        parts = []
        vertices.append([min(minx+dx*j,maxx),max(maxy-dy*i,miny)])
        vertices.append([min(minx+dx*(j+1),maxx),max(maxy-dy*i,miny)])
        vertices.append([min(minx+dx*(j+1),maxx),max(maxy-dy*(i+1),miny)])
        vertices.append([min(minx+dx*j,maxx),max(maxy-dy*(i+1),miny)])
        parts.append(vertices)
        w.poly(parts)
        w.record(id)

# w.save('polygon_grid_10')
w.save(fileBaseName)

# Test using script:
# python generateEmptyGrid.py 6262492.020081 448262.080078 6262938.950073 450360.750122 50 50 emptyGrid_50mCells-2      # WORKS
# python generateEmptyGrid.py -97.546649 32.550058 -97.034774 32.987978 50 50 emptyGrid_50mCells-3                      # SINGLE CELL of indeterminate size.
# python generateEmptyGrid.py 32.550058 -97.546649 32.987978 -97.034774 50 50 emptyGrid_50mCells-4                      # SINGLE CELL of indeterminate size.

# Test using BNG.
# python generateEmptyGrid.py -9690512 6837338 -9470413 6679997 50 50 emptyGrid_50mCells_DFW_BNG                        # FAILS - HANGS.

# Need to convert WGS84 to british national grid first!!
# https://gist.github.com/lfigueira/58ad4a5cea1a5d8a92d7

# Conversion Table
"""
-97.546649 32.550058

Easting: -9690512
-97° 27' 12.064"

Northing: 6837338
32° -27' 0.209"


-97.034774 32.987978

Easting: -9470413
-97° -2' - 5.186"

Northing: 6679997
32° -1' 16.721"

"""
